
\documentclass[12pt]{article}\usepackage[]{graphicx}\usepackage[]{xcolor}
% maxwidth is the original width if it is less than linewidth
% otherwise use linewidth (to make sure the graphics do not exceed the margin)
\makeatletter
\def\maxwidth{ %
  \ifdim\Gin@nat@width>\linewidth
    \linewidth
  \else
    \Gin@nat@width
  \fi
}
\makeatother

\definecolor{fgcolor}{rgb}{0.345, 0.345, 0.345}
\newcommand{\hlnum}[1]{\textcolor[rgb]{0.686,0.059,0.569}{#1}}%
\newcommand{\hlstr}[1]{\textcolor[rgb]{0.192,0.494,0.8}{#1}}%
\newcommand{\hlcom}[1]{\textcolor[rgb]{0.678,0.584,0.686}{\textit{#1}}}%
\newcommand{\hlopt}[1]{\textcolor[rgb]{0,0,0}{#1}}%
\newcommand{\hlstd}[1]{\textcolor[rgb]{0.345,0.345,0.345}{#1}}%
\newcommand{\hlkwa}[1]{\textcolor[rgb]{0.161,0.373,0.58}{\textbf{#1}}}%
\newcommand{\hlkwb}[1]{\textcolor[rgb]{0.69,0.353,0.396}{#1}}%
\newcommand{\hlkwc}[1]{\textcolor[rgb]{0.333,0.667,0.333}{#1}}%
\newcommand{\hlkwd}[1]{\textcolor[rgb]{0.737,0.353,0.396}{\textbf{#1}}}%
\let\hlipl\hlkwb

\usepackage{framed}
\makeatletter
\newenvironment{kframe}{%
 \def\at@end@of@kframe{}%
 \ifinner\ifhmode%
  \def\at@end@of@kframe{\end{minipage}}%
  \begin{minipage}{\columnwidth}%
 \fi\fi%
 \def\FrameCommand##1{\hskip\@totalleftmargin \hskip-\fboxsep
 \colorbox{shadecolor}{##1}\hskip-\fboxsep
     % There is no \\@totalrightmargin, so:
     \hskip-\linewidth \hskip-\@totalleftmargin \hskip\columnwidth}%
 \MakeFramed {\advance\hsize-\width
   \@totalleftmargin\z@ \linewidth\hsize
   \@setminipage}}%
 {\par\unskip\endMakeFramed%
 \at@end@of@kframe}
\makeatother

\definecolor{shadecolor}{rgb}{.97, .97, .97}
\definecolor{messagecolor}{rgb}{0, 0, 0}
\definecolor{warningcolor}{rgb}{1, 0, 1}
\definecolor{errorcolor}{rgb}{1, 0, 0}
\newenvironment{knitrout}{}{} % an empty environment to be redefined in TeX

\usepackage{alltt}
\usepackage{amsmath,amssymb}
\usepackage{graphicx}
\usepackage{enumerate}
\usepackage{natbib}
\usepackage{soul}
\usepackage{xcolor}
\usepackage{url} 
\newcommand\eic[1]{{\textcolor{orange}{#1}}}
\newcommand\pnc[1]{{\textcolor{blue}{#1}}}
\usepackage{fullpage}
\bibliographystyle{apalike}

%% code macros
\newcommand\proglang[1]{\textsf{#1}} 
\newcommand\code[1]{\texttt{#1}}
\newcommand{\pkg}[1]{{\fontseries{b}\selectfont #1}}
\newcommand\slot[1]{\code{#1}}
\newcommand\class[1]{class `\code{#1}'}
\newcommand\Class[1]{Class `\code{#1}'}

%% basic POMP definitions
\newcommand\Xspace{{\mathbb X}}
\newcommand\Yspace{{\mathbb Y}}
%\newcommand\Thetaspace{{\Theta}}
%\newcommand\vecTheta{\vec{\Theta}}
\newcommand\vecTheta{\Theta}
\newcommand\Thetaspace{\R^{\Thetadim}}
\newcommand\hatTheta{\widehat{\Theta}}
\newcommand\Xdim{{\mathrm{dim}}(\Xspace)}
\renewcommand\Xdim{D_X}
\renewcommand\Xspace{{\R^{\Xdim}}}
\newcommand\Ydim{{\mathrm{dim}}(\Yspace)}
\renewcommand\Yspace{\R}
%\newcommand\Thetadim{{\mathrm{dim}}(\Thetaspace)}
\newcommand\Thetadim{D_\theta}
\newcommand\thetadim{d_\theta}
%\newcommand\vectheta{\vec{\theta}}
\newcommand\vectheta{\theta}
\newcommand\timeSet{{\mathbb T}}
\newcommand\data[1]{#1^*}

\newcommand\unitSpecific{\hspace{0.1mm}\mathrm{us}}
\newcommand\shared{\hspace{0.15mm}\mathrm{sh}}
\newcommand\RP{\hspace{0.15mm}\mathrm{RP}}
\newcommand\IVP{\hspace{0.15mm}\mathrm{IVP}}

%% for bagged filters
\newcommand\ABF{ABF}
\newcommand\ABFIR{ABF-IR}
\newcommand\UBF{UBF}
\newcommand\rep{i}
\newcommand\altRep{\tilde\rep}
\newcommand\Rep{\mathcal{I}}


%% for particle filters
\newcommand\unit{u}
\newcommand\altUnit{\tilde{u}}
\newcommand\Unit{U}
\usepackage[mathscr]{euscript}
\renewcommand\time{n}
\renewcommand\vec[1]{\boldsymbol{#1}}
\newcommand\altTime{\tilde{n}}
\newcommand\Time{N}
\newcommand\Np{J}
\newcommand\np{j}
\newcommand\altNp{q}
\newcommand\altAltNp{\tilde{j}}
\newcommand\resampleIndex{r}

%% customized math macros
%\newcommand\prob[1]{\mathbb{P}\left[{#1}\right]}
\newcommand\prob{\mathbb{P}}
\newcommand\dd[1]{\mathrm{d}{#1}}
\newcommand\given{{\,\vert\,}}
\newcommand\equals{{{\,}={\,}}}
\newcommand\myequals{\hspace{0.5mm}{=}\hspace{0.5mm}}
\newcommand\myto{{\;:\;}}
\newcommand\seq[2]{{#1}\!:\!{#2}}
\newcommand\mydot{{\,\cdot\,}}
\newcommand\cp[2]{N_{\mathrm{#1}\mathrm{#2}}}
%\newcommand\BirthDeath{\raisebox{-0.3ex}{\scalebox{1.5}{$\cdot$}}}
%\newcommand\dlta[1]{\Delta{#1}}
\newcommand\giventh{{\hspace{0.5mm};\hspace{0.5mm}}}
\newcommand\normal{{\mathrm{Normal}}}
\newcommand\argequals{{\,=\,}}
\newcommand\lags{c}
\newcommand\maxlag{\overline{c}}
\newcommand\nlfList{C}
\newcommand\bigO{\mathcal{O}}
%\newcommand\loglik{\ell}
\newcommand\loglik{\lambda}
\newcommand\loglikMC{\MC{\loglik}}
\newcommand\loglikComponent{c}
\newcommand\R{\mathbb{R}}
\newcommand\param{\,;}
\newcommand\mycolon{{\hspace{0.6mm}:\hspace{0.6mm}}}
\newcommand\MC[1]{#1^{\mbox{\tiny MC}}}
\newcommand\Var{\mathrm{Var}}
\newcommand\var{\Var}
\newcommand\Cov{\mathrm{Cov}}
\newcommand\cov{\Cov}
\newcommand\iid{\mathrm{iid}}
\newcommand\dist{\mathrm{dist}}
\newcommand\transpose{t}












\title{Using an iterated block particle filter via \pkg{spatPomp}}
\author{Ning Ning and Edward L. Ionides}
\date{\today}
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\begin{document}
\maketitle

The IBPF algorithm studied by \citet{ning21-ibpf} and \citet{ionides22} has been contributed to the \proglang{R} package \pkg{spatPomp} \citep{asfaw21cran,asfaw21arxiv} as the function  \code{ibpf}.
This document introduces \code{ibpf} and validates its correctness on a simple Gaussian example which is tractable using the Kalman filter.
In addition to the \pkg{spatPomp} code presented here, the full code to reproduce this document is available in its R Noweb (\code{.Rnw}) source file. 

Consider spatial units $1,\dots,\Unit$ located evenly around a circle, where $\dist(\unit,\altUnit)$ is the circle distance,
\[
\dist(\unit,\altUnit)
= \min\big(|\unit-\altUnit|, |\unit-\altUnit+\Unit|, |\unit-\altUnit-\Unit|\big).
\]
The latent process is a $\Unit$-dimensional Brownian motion $\vec{X}(t)$ having correlation that decays with distance.
Specifically,
\[
dX_\unit(t)= \sum_{\altUnit=1}^{\Unit} \rho_{\unit}^{\dist(\unit,\altUnit)} \, dW_{\altUnit}(t),
\]
where $W_{1}(t),\dots,W_{\Unit}(t)$ are independent Brownian motions with infinitesimal variance $\sigma_{\unit}^2$, and $|\rho_{\unit}| <1$.
An observation $Y_n$ is made at each time $t_n=n$ for $n=1,2,\dots,N$, and we write $X_n=X(t_n)$.
We suppose our measurement model for discrete-time observations of the latent process is
\[
Y_{\unit,\time}=X_{\unit,\time} + \eta_{\unit,\time}
\]
where  $\eta_{\unit,\time}\overset{\text{iid}}{\sim} \normal(0,\tau_{\unit}^2)$.
The model is completed by providing the initial conditions, $\{X_\unit(0), \unit \in 1:\Unit \}$, at time $t_0=0$.
These initial conditions are specified as parameters.
An instance of this model is generated below, using the \code{bm2} function.



%%%%%% iiiiiiii %%%%
\begin{knitrout}
\definecolor{shadecolor}{rgb}{1, 1, 1}\color{fgcolor}\begin{kframe}
\begin{verbatim}
R> library(spatPomp)
R> i <- 2
R> b <- bm2(U=4,N=switch(i,20,200),unit_specific_names="rho")
R> plot(b)
\end{verbatim}
\end{kframe}

\includegraphics[width=\textwidth]{figure/bm-model-1} \hfill{}


\end{knitrout}



Here, \code{i} is a computational intensity switch which adjusts the code for varying run-time.
We set \code{i=1} for testing and debugging, and \code{i=2} for higher quality results.
For simplicity, we consider only one unit-specific parameter, $\rho_{\unit}$, with other parameters being fixed at a value shared between units.
The simulation for \code{b} has $\rho_u=0.4$ for all $\unit$, but the estimators do not know this.
Before carrying out inference, we check likelihood evaluation.
For this toy model, the \pkg{spatPomp} function \code{bm2\_kalman\_logLik} provides an exact log-likelihood via the Kalman filter.
This study uses a sufficiently small number of units (\code{U=4}) that the particle filter is numerically tractable.
We use the particle filter provided by the \pkg{pomp} package \citep{king16}, taking advantage of the class structure where \class{spatPomp} inherits from \class{pomp}.
We can readily validate the agreement between \code{bm2\_kalman\_logLik} and \code{pfilter}, and identify the likelihood cost of the block filter approximation in this situation.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{1, 1, 1}\color{fgcolor}\begin{kframe}
\begin{verbatim}
R> kf_logLik <- bm2_kalman_logLik(b)
R> pf_logLik <- replicate(10,
+    logLik(pfilter(b,switch(i,10,1000)))
+  )
R> bpf_logLik2 <- replicate(10,
+    logLik(bpfilter(b,switch(i,10,1000),block_size=2))
+  )
\end{verbatim}
\end{kframe}
\end{knitrout}



\begin{table}
\begin{tabular}{llrrrrr}
               & & KF & PF & BPF & BPF & BPF
	       \\
               & &  &  & ($K=1$) & ($K=2$) & ($K=4$)
	       
\\
\hline
Log-likelihood & mean &
  -1472.69 &
  -1480.79 &
  -1477.88 &
  -1509.06 &
  -1547.80 
\\  
               & sd &
  0.00 &
  3.96 &
  4.00 &
  2.07 &
  1.49 
\end{tabular}
\caption{Likelihood evaluation for the \code{bm2} model object, \code{b}, using the Kalman filter (KF), particle filter (PF), and block particle filter (BPF) with varying numbers of blocks ($K$).
For Monte Carlo filters, the mean and standard deviation are shown for 10 replicates.
}\label{tab:lik-eval}
\end{table}

Table~\ref{tab:lik-eval} shows the increasingly negative bias, and decreasing variance, of BPF as the number of blocks increases.
For a single block, $K=1$, the BPF algorithm matches PF.
PF provides an unbiased estimate of the likelihood, and due to the convexity of the logarithm it has negative bias (approximately equal to half the variance) for estimating the log-likelihood.
Subsequently, we investigate inference for $\rho_{1:4}$ with $K=2$.

\citet{ionides21} investigated a range of values for $U$ for this model in their Figure~1, and for an epidemiological model their Figure~3.
The small scenario considered here, with $U=4$, is designed for the following purposes: (i) to validate whether or not \code{ibpf} is correctly coded by comparison with direct calculations using the Kalman filter; (ii) to check whether or not the block approximation has considerable adverse effects on inference in this case.
The inherent scalability of BPF and IBPF means that results for $U=4$ are applicable to behavior on larger systems.

For our test of IBPF, we start searches at $\rho_u=u/5$ to investigate the effect (if any) on starting value.







\begin{knitrout}
\definecolor{shadecolor}{rgb}{1, 1, 1}\color{fgcolor}\begin{kframe}
\begin{verbatim}
R> rho_start <- seq(from=0.2,to=0.8,length=U)
R> params_start <- coef(b)
R> params_start[paste0("rho",1:U)] <- rho_start
R> ibpf_mle_searches <- foreach(reps=1:switch(i,3,10))%dopar%{
+    ibpf(b,params=params_start,
+      Nbpf=switch(i,2,50),Np=switch(i,20,1000),
+      rw.sd=rw.sd(rho1=0.02,rho2=0.02,rho3=0.02,rho4=0.02),
+      unitParNames="rho",
+      sharedParNames=NULL,
+      block_size=2,
+      spat_regression=0,
+      cooling.fraction.50=0.5
+    )
+  }
\end{verbatim}
\end{kframe}
\end{knitrout}




To assess the success of these searches, we evaluate the likelihood of the resulting parameter estimates using the Kalman filter.
The highest likelihood found in these ten searches was -1472.93
 which is not far from the actual maximum of -1472.11.
However, the median of -1475.00 reveals that substantial Monte Carlo maximization error is present.
It can be intractable to increase computational effort to the point where the Monte Carlo error is negligible, and instead we emphasize methods that quantify and control this.

The MLE may be of less interest than marginal confidence intervals for each unit-specific parameter.
Therefore, we compute a profile likelihood for each $u$. 
We calculate a profile likelihood for each value of $u$, using Monte Carlo adjusted profile methodology \citep{ionides17,ning21}. 
We compare this with an exact likelihood profile constructed by numerical optimization of the log-likelihood evaluated using the Kalman filter.
The IBPF implementation is identical to the search above, except that the profiled parameter is fixed.
For the profile shown in Figure~\ref{fig:ibpf-prof1-plot}, we first evaluate the likelihood using BPF rather than the Kalman filter, to present methodology applicable to non-Gaussian models.
We then check against the likelihood evaluated via the Kalman filter for the IBPF estimates, and the profile computed directly from the Kalman filter.
These reveal a distinct bias in the IBPF/BPF profile, apparently primarily to do with a bias in likelihood evaluation.
The parameter in question describes a dynamic coupling between the units, and it seems that the blocking procedure breaks some of the coupling and thereby infers a higher value of the coupling parameter that used for the simulation.
The bottom panel of Figure~\label{fig:ibpf-prof1-plot} shows that we can also diagnose this effect using the particle filter, on this small example for which the particle filter is tractable.






The profile took 56.11 mins using 10 computing cores.
Likelihood evaluation took 25.07, shared between BPF and PF.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{1, 1, 1}\color{fgcolor}\begin{figure}

\includegraphics[width=5.5in]{figure/ibpf-prof1-plot-1} \hfill{}

\caption[Top]{Top: profile for $\rho_1$ using an IBPF search with likelihood computed using BPF, for $K=2$ blocks each having 2 units. Middle: Exact profile (dashed red line) and the same IBPF search with likelihood computed exactly using the Kalman filter. Bottom: The same IBPF search with likelihood computed using the particle filter.}\label{fig:ibpf-prof1-plot}
\end{figure}

\end{knitrout}

We now do the same calculation for $\sigma$ for comparison with $\rho$.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{1, 1, 1}\color{fgcolor}\begin{kframe}
\begin{verbatim}
R> set.seed(20)
R> b_sig <- bm2(U=4,N=switch(i,20,200),unit_specific_names="sigma")
R> # b_sig has the same data as b
R> # plot(b_sig)
R> 
R>   bm2_sig_negLogLik <- function(sigma){
+      coef(b_sig,names(sigma)) <- unname(sigma)
+      -bm2_kalman_logLik(b_sig)
+    }
R> 
R> stew(file=paste0(out_dir,"kf_mle_sig.rda"),seed=256,{
+    sigma_init <- c(sigma1=1,sigma2=1,sigma3=1,sigma4=1)
+    bm2_sig_negLogLik(sigma_init)
+    bm2_sig_mle <- optim(sigma_init,bm2_sig_negLogLik)
+  })
\end{verbatim}
\end{kframe}
\end{knitrout}









The $\sigma_1$ profile took 55.87 mins using 10 computing cores.
Likelihood evaluation took 23.72, shared between BPF and PF.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{1, 1, 1}\color{fgcolor}\begin{figure}

\includegraphics[width=5.5in]{figure/ibpf-prof-sig1-plot-1} \hfill{}

\caption[Top]{Top: profile for $\sigma_1$ using an IBPF search with likelihood computed using BPF, for $K=2$ blocks each having 2 units. Middle: Exact profile (dashed red line) and the same IBPF search with likelihood computed exactly using the Kalman filter. Bottom: The same IBPF search with likelihood computed using the particle filter.}\label{fig:ibpf-prof-sig1-plot}
\end{figure}

\end{knitrout}


We now proceed to carry out a similar analysis for the measles model generated by \code{he10}.
This is a susceptible-exposed-infected-recovered model for measles transmission, described by \citet{ionides22} and \citet{asfaw21arxiv}.
For this model, exact likelihood evaluation is not available.
However, for a relatively small number of units ($U=4$) the particle filter provide an adequate approximation.
\citet{ionides22} considered fitting this model to data using IBPF, with 20 cities and up to $20\times 13$ parameters.
Here, our task is to focus on a smaller, simulated dataset, estimating fewer parameters in order to assess more clearly whether or not the block approximation is leading to substantial bias.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{1, 1, 1}\color{fgcolor}\begin{kframe}
\begin{verbatim}
R> he10_model <- he10(U=4,dt=1/365,Tmax=1964,expandedParNames=c("R0"),
+    basic_params = c(
+      alpha =0.99,      iota=0,          R0=30,
+      cohort=0.5,  amplitude=0.3,     gamma=52,
+      sigma=52,           mu=0.02,  sigmaSE=0.05,
+      rho=0.5,           psi=0.1,         g=1000,
+      S_0=0.036,         E_0=0.00007,   I_0=0.00006
+    )
+  )
R> m <- simulate(he10_model,seed=9)
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}
\definecolor{shadecolor}{rgb}{1, 1, 1}\color{fgcolor}

\includegraphics[width=\textwidth]{figure/model-he10-eval-1} \hfill{}




\includegraphics[width=\textwidth]{figure/model-he10-eval-2} \hfill{}


\end{knitrout}



Likelihood evaluation took 23.72 mins.

\begin{table}
\begin{tabular}{llrrrr}
               & & PF & BPF & BPF & BPF
	       \\
               & &  & ($K=1$) & ($K=2$) & ($K=4$)
	       
\\
\hline
Log-likelihood & mean &
  -13130.10 &
  -13128.68 &
  -13081.59 &
  -13077.25 
\\  
               & sd &
  17.44 &
  11.01 &
  5.38 &
  1.47 
\end{tabular}
\caption{Likelihood evaluation for the \code{he10} model object, \code{m}, using the particle filter (PF), and block particle filter (BPF) with varying numbers of blocks ($K$).
The mean and standard deviation are shown for 10 replicates with $10^4$ particles.
}\label{tab:m-lik-eval}
\end{table}







The $\R0_1$ profile took 1018.91 mins using 10 computing cores.
Likelihood evaluation took 809.97, shared between BPF and PF.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{1, 1, 1}\color{fgcolor}\begin{figure}

\includegraphics[width=5.5in]{figure/m-prof-sig1-plot-1} \hfill{}

\caption[Top]{Top: profile for $R0_1$ using an IBPF search with likelihood computed using BPF, for $K=4$ blocks each having 1 unit. Middle: Exact profile (dashed red line) and the same IBPF search with likelihood computed exactly using the Kalman filter. Bottom: The same IBPF search with likelihood computed using the particle filter.}\label{fig:m-prof-sig1-plot}
\end{figure}

\end{knitrout}


\bibliography{bib-bm}

\end{document}
